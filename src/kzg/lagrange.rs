//! This module computes commitments to the Lagrange basis polynomials on a size `n`
//! multiplicative subgroup using an SRS of the form `[τ^j]G` for `j = 0..n-1`.
//!
//! Two building blocks are provided:
//! - `compute_lagrange_basis_commitments` — given the SRS `[G, τG, …, τ^{n-1}G]`, it returns
//!   the commitments `[L_i(τ)]_G` for the Lagrange basis polynomials over the domain
//!   `{1, ω, ω^2, …, ω^{n-1}}` where `ω` is a primitive `n`‑th root of unity.
//! - `construct_lagrange_basis` — constructs the polynomials `L_i(x)` for a domain
//!   generated by a given root.
//!
//! ## Conventions
//! - `n` must be a power of two.

use icicle_core::curve::{Curve, Affine, Projective};
use icicle_core::traits::FieldImpl;
use icicle_core::ntt::{NTTDomain, get_root_of_unity};
use icicle_core::traits::Arithmetic;
use crate::utils::{is_pow_2, to_affine_batched};
use icicle_core::polynomials::UnivariatePolynomial;
use icicle_runtime::memory::HostSlice;

/// Computes commitments to the Lagrange basis `{L_i(x)}` on the size `n` domain using an SRS `[τ^j]G`.
///
/// # Parameters
/// - `tau_powers` — slice containing `[G, τG, …, τ^{n-1}G]`.
///
/// # Returns
/// A vector of affine points `[(L_0(τ))G, …, (L_{n-1}(τ))G]` in the same order as the domain
/// points `[1, ω, ω^2, …]`.
///
/// # Complexity
/// `O(n^2)` group scalar multiplications.
/// 
/// # Panics
/// Panics if `n` is not a power of two.
pub fn compute_lagrange_basis_commitments<C>(srs: &[Projective::<C>]) -> Vec<Affine::<C>>
where
    C: Curve,
    C::ScalarField: FieldImpl,
    <C as Curve>::ScalarField: Arithmetic,
    <<C as Curve>::ScalarField as FieldImpl>::Config: NTTDomain<<C as Curve>::ScalarField>,
{
    let len = srs.len();
    assert!(is_pow_2(len));

    let omega = get_root_of_unity::<C::ScalarField>((len).try_into().unwrap());
    let omega_inv = omega.inv();
    let len_inv = C::ScalarField::from_u32((len).try_into().unwrap()).inv();
    
    let mut projective_out = Vec::with_capacity(len);
    
    // L_i(τ)G = (1/len) * Σ_j ψ^{i*j} · [τ^j]G
    for i in 0..len {
        // round_initial_omega = ψ^i
        let round_initial_omega = omega_inv.pow((i).try_into().unwrap());
        let mut omega_i = C::ScalarField::one();

        let mut acc = Projective::<C>::zero();
        for srs_j in srs {
            acc = acc + C::mul_scalar(*srs_j, omega_i);
            // ψ^{i*(j+1)}
            omega_i = omega_i * round_initial_omega;
        }
        
        // scale by 1/len
        acc = C::mul_scalar(acc, len_inv);

        projective_out.push(acc);
    }

    to_affine_batched(&projective_out)
}

/// Constructs the Lagrange basis polynomials `{L_0(x), …, L_{n-1}(x)}` over the domain
/// `D = {1, root, root^2, …, root^{n-1}}`.
///
/// Each basis element is
/// ```text
/// L_i(x) = Π_{j!=i} (x - x_j) / (x_i - x_j), where x_n = root^n.
/// ```
///
/// # Parameters
/// * `n` — domain size which must be match the SRS used for commitments.
/// * `root` — a primitive `n`‑th root of unity generating the domain `D`.
///
/// # Returns
/// Vector of polynomials implementing [`UnivariatePolynomial`].
pub fn construct_lagrange_basis<C, P>(n: usize, root: C::ScalarField) -> Vec<P>
where
    C: Curve,
    C::ScalarField: FieldImpl,
    <C as Curve>::ScalarField: Arithmetic,
    P: UnivariatePolynomial<Field = <C as Curve>::ScalarField>,
{
    // Precompute the domain points x_n = root^n
    let mut roots = Vec::with_capacity(n);
    // root^0
    let mut pow = C::ScalarField::one();
    for _ in 0..n {
        roots.push(pow);
        //root^{n+1}
        pow = pow * root;
    }
    
    // Build each L_i(x) by multiplying terms (x - x_j)/(x_i - x_j)
    let mut bases = Vec::with_capacity(n);
    
    // For each basis with index i, evaluate the inner sum at ψ^i
    for i in 0..n {
        // L_i(x)
        let coeff = vec![C::ScalarField::one(), C::ScalarField::zero()];
        let mut li = P::from_coeffs(HostSlice::from_slice(&coeff), 2);

        let x_i = roots[i];

        for (j, &x_j) in roots.iter().enumerate() {
            if j == i { continue; }

            // Form the factor (x - x_j)/(x_i - x_j)
            // 1/(x_i - x_j)
            let bottom_inv = (x_i - x_j).inv();
            // -(x_j/(x_i - x_j))
            let c0 = C::ScalarField::zero() - (x_j * bottom_inv);
            // x/(x_i - x_j))
            let c1 = bottom_inv;
            let lj = P::from_coeffs(HostSlice::from_slice(&[c0, c1]), 2);
            li = li.mul(&lj);
        }

        bases.push(li);
    }
    bases
}

#[cfg(test)]
mod lagrange_test {
    use icicle_bn254::curve::CurveCfg as Bn254CurveCfg;
    use icicle_bn254::curve::ScalarField as Bn254ScalarField;
    use icicle_core::curve::{Curve,Affine,Projective};
    use icicle_core::polynomials::UnivariatePolynomial;
    use icicle_bn254::polynomials::DensePolynomial as Bn254Poly;
    use icicle_core::traits::FieldImpl;
    use icicle_core::ntt::{get_root_of_unity, initialize_domain, NTTInitDomainConfig, release_domain};
    use std::ops::Mul;

    use crate::{
        kzg::lagrange::{compute_lagrange_basis_commitments, construct_lagrange_basis},
        utils::srs::unsafe_setup_from_tau,
    };

    #[test]
    fn test_lagrange() {
        let n: usize = 16;
        let domain = get_root_of_unity::<Bn254ScalarField>((n * n * n * n).try_into().unwrap());
        initialize_domain(domain, &NTTInitDomainConfig::default()).unwrap();
        
        let root = get_root_of_unity::<Bn254ScalarField>((n).try_into().unwrap());
        
        let lb = construct_lagrange_basis::<Bn254CurveCfg, Bn254Poly>(n, root);

        let tau = Bn254ScalarField::from_u32(19u32);
        let srs = unsafe_setup_from_tau::<Bn254CurveCfg>(n - 1, tau);
        
        let mut lb_commitments_from_tau: Vec<Affine::<Bn254CurveCfg>> = Vec::with_capacity(lb.len());
        for i in 0..lb.len() {
            let li_tau = lb[i].eval(&tau);
            let projective_result = Bn254CurveCfg::get_generator().mul(li_tau);
            let mut affine_result = Affine::<Bn254CurveCfg>::zero();
            Bn254CurveCfg::to_affine(&projective_result, &mut affine_result);
            lb_commitments_from_tau.push(affine_result);
        }

        let srs_projective: Vec<Projective::<Bn254CurveCfg>> = srs.iter().map(|c| c.to_projective()).collect();
        let lb_commitments = compute_lagrange_basis_commitments(&srs_projective);
        
        release_domain::<Bn254ScalarField>().unwrap();

        assert_eq!(lb_commitments_from_tau, lb_commitments);
    }
}